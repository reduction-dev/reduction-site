---
sidebar_position: 3
---

import mainGo from '!!raw-loader!@site/examples/deploy-go/main.go';
import cdkApp from '!!raw-loader!@site/examples/deploy-go/cdk/bin/app.ts';
import cdkJobManagerService from '!!raw-loader!@site/examples/deploy-go/cdk/lib/constructs/job-manager-service.ts';
import cdkWorkerService from '!!raw-loader!@site/examples/deploy-go/cdk/lib/constructs/worker-service.ts';
import cdkHandlerService from '!!raw-loader!@site/examples/deploy-go/cdk/lib/constructs/handler-service.ts';
import cdkReductionStack from '!!raw-loader!@site/examples/deploy-go/cdk/lib/reduction-stack.ts';
import CodeSnippet from '@site/src/components/CodeSnippet';

# Deploying to ECS With CDK

This guide shows you how to deploy a Reduction cluster on AWS ECS with CDK.

This demo uses a basic "word count" job that reads data from a Kinesis stream
and logs the count of each word when it changes.

<details>
<summary>Word Count Reduction Job</summary>
<CodeSnippet language="go" code={mainGo} />
</details>

This demo code makes cost friendly decisions:
- Deploy to public subnets to avoid more expensive VPC resources
associated with private subnets.
- Run on ARM
- Deploy with low-resource Fargate Spot instances
- Set retain policies to destroy so taht deleting the stack removes all resources

## Tools Used

- **[AWS CDK][cdk]**: An infrastructure as code tool used to generate CloudFormation
templates. AWS CDK works best with TypeScript.
- **[Bun][bun]**: Bun is a Node compatible runtime used to run the CDK code.
- **[Go][go]**: The Reduction job is written in Go using the Reduction Go SDK.
- **[Docker][docker]**: This deployment uses containers to deploy both the Reduction Engine
components and the Handler service.
- **[ECS][ecs]**: ECS is AWS's proprietary container orchestration tool for Deploying
Docker containers.
- **[Fargate][fargate]**: Low-maintenance compute for provisioning CPU and memory to run
services.
- **[Service Connect][service-connect]**: AWS's Envoy integration for ECS. This provides DNS
entries to call services without requiring a load balancer.

[cdk]: https://aws.amazon.com/cdk/
[bun]: https://bun.sh/
[go]: https://go.dev/
[docker]: https://www.docker.com/
[ecs]: https://aws.amazon.com/ecs/
[fargate]: https://aws.amazon.com/fargate/
[service-connect]: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html

## Building Job Handler and Config

The Reduction Handler code that you write defines the job's configuration and
creates the Handler Service that the reduction engine calls. To deploy you'll
first want to build the handler code and write the job configuration file. You
can do this anywhere you like in your CI process but for this example we'll
build these artifacts as part of the CDK synthesis process.

Building the handler executable:

<CodeSnippet language="typescript" code={cdkApp} marker="build-handler" />

Writing the config file to disk:

<CodeSnippet language="typescript" code={cdkApp} marker="write-config" />

## The Job Manager ECS Service

The Job Manager services needs:

1. **The Reduction Docker image**

    A Docker image containing the Reduction binary. Tasks run the `reduction
    job` command.

1. **The job.config file**

    The Job Manager needs the job.config file and runtime values to resolve
    configuration parameters. In this case we provide a Kinesis stream ARN, a
    working storage path, and the number of workers in the cluster.

1. **Well-known network address**

    When the Reduction cluster boots, workers register with the Job Manager. To
    make the Job Manager available on the network we'll use Service Connect to
    give it a well-known endpoint.

1. **Write access to an S3 Bucket**

    The job writes checkpoints to an S3 Bucket.

1. **Network access to communicate with workers**

    We use a shared security group as a simple way to let the Job Manager
    and the worker nodes to call each other.

<details>
<summary>Job Manager Service</summary>
<CodeSnippet language="typescript" code={cdkJobManagerService} />
</details>

## The Worker ECS Service

The `WorkerService` runs instances of Reduction workers. This service needs:

1. **The Reduction Docker image**

    A Docker image containing the Reduction binary. Tasks run the `reduction
    worker` command.

1. **The Job Manager endpoint**

    Workers use the Job Manager endpoint to register when they boot.

1. **Network access to communicate with the Job Manager and the Handler**

    The workers share a security gorup with the Job Manager and the
    `WorkerService` construct implements `ec2.IConnectable` to configure access
    to the Handler. `WorkerService` is passed a `jobManagerEndpoint` and a
    `handlerEndpoint` to call.

1. **Access read from the job source**

    `WorkerService` implements `iam.IGrantable` so that we can grant access
    to read the Kinesis stream.

<details>
<summary>Worker Service</summary>
<CodeSnippet language="typescript" code={cdkWorkerService} />
</details>

## The Handler Service

The Handler service runs your job code that the Reduction workers call. This
could be an AWS Lambda with a function URL, a service behind a load balancer, or
any compute capable of servicing HTTP requests.

This Handler service needs:

1. **A Docker image with your handler code**

    Create a Dockerfile with that runs your handler executable.

2. **A well-known network address**

    The serivce runs on an ECS cluster configured with a namespace for Service
    Connect. The `HandlerService` construct exposes an `endpoint` address for
    the Workers to call which routes calls to `HandlerService` tasks.

<details>
<summary>Handler Service</summary>
<CodeSnippet language="typescript" code={cdkHandlerService} />
</details>

# Reduction Stack - Connecting the Service Components

The `ReductionStack` is the deployed CloudFormation stack that composes our
three services and creates our data dependencies (S3 Bucket, Kinesis Stream).

This stack creates:
- An S3 bucket that Reduction uses for persistent storage.
- A Kinesis stream used as a source input for a stream of words to count.
- The ECS cluster to deploy the services into.
- The shared security group for the Reduction Job Manager and Worker
services.
- A custom resource that puts words on the Kinesis stream after deploying
so that we can see the job process Kinesis records.

<details>
<summary>Reduction Stack</summary>
<CodeSnippet language="typescript" code={cdkReductionStack} />
</details>

## Deploying the Stack

To deploy this stack:

```
bun cdk deploy
```

When you're finished with your stack you can run `destroy` to remove all of the
resources.

```
bun cdk destroy
```
